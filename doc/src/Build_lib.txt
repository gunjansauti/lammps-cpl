"Higher level section"_Build.html - "LAMMPS WWW Site"_lws - "LAMMPS
Documentation"_ld - "LAMMPS Commands"_lc :c

:link(lws,http://lammps.sandia.gov)
:link(ld,Manual.html)
:link(lc,Section_commands.html#comm)

:line

Build LAMMPS as a library :h3

LAMMPS can be built as either a static or shared library, which can
then be called from another application or a scripting language.  See
"this section"_Section_howto.html#howto_10 for more info on coupling
LAMMPS to other codes.  See "this section"_Section_python.html for
more info on wrapping and running LAMMPS from Python.

Static library :h5

To build LAMMPS as a static library (*.a file on Linux), type

make foo mode=lib :pre

where foo is the machine name.  This kind of library is typically used
to statically link a driver application to LAMMPS, so that you can
insure all dependencies are satisfied at compile time.  This will use
the ARCHIVE and ARFLAGS settings in src/MAKE/Makefile.foo.  The build
will create the file liblammps_foo.a which another application can
link to.  It will also create a soft link liblammps.a, which will
point to the most recently built static library.

Shared library :h5

To build LAMMPS as a shared library (*.so file on Linux), which can be
dynamically loaded, e.g. from Python, type

make foo mode=shlib :pre

where foo is the machine name.  This kind of library is required when
wrapping LAMMPS with Python; see "Section 11"_Section_python.html
for details.  This will use the SHFLAGS and SHLIBFLAGS settings in
src/MAKE/Makefile.foo and perform the build in the directory
Obj_shared_foo.  This is so that each file can be compiled with the
-fPIC flag which is required for inclusion in a shared library.  The
build will create the file liblammps_foo.so which another application
can link to dynamically.  It will also create a soft link liblammps.so,
which will point to the most recently built shared library.  This is
the file the Python wrapper loads by default.

Note that for a shared library to be usable by a calling program, all
the auxiliary libraries it depends on must also exist as shared
libraries.  This will be the case for libraries included with LAMMPS,
such as the dummy MPI library in src/STUBS or any package libraries in
lib/packages, since they are always built as shared libraries using
the -fPIC switch.  However, if a library like MPI or FFTW does not
exist as a shared library, the shared library build will generate an
error.  This means you will need to install a shared library version
of the auxiliary library.  The build instructions for the library
should tell you how to do this.

Here is an example of such errors when the system FFTW or provided
lib/colvars library have not been built as shared libraries:

/usr/bin/ld: /usr/local/lib/libfftw3.a(mapflags.o): relocation
R_X86_64_32 against '.rodata' can not be used when making a shared
object; recompile with -fPIC
/usr/local/lib/libfftw3.a: could not read symbols: Bad value :pre

/usr/bin/ld: ../../lib/colvars/libcolvars.a(colvarmodule.o):
relocation R_X86_64_32 against '__pthread_key_create' can not be used
when making a shared object; recompile with -fPIC
../../lib/colvars/libcolvars.a: error adding symbols: Bad value :pre

As an example, here is how to build and install the "MPICH
library"_mpich, a popular open-source version of MPI, distributed by
Argonne National Labs, as a shared library in the default
/usr/local/lib location:

:link(mpich,http://www-unix.mcs.anl.gov/mpi)

./configure --enable-shared
make
make install :pre

You may need to use "sudo make install" in place of the last line if
you do not have write privileges for /usr/local/lib.  The end result
should be the file /usr/local/lib/libmpich.so.

